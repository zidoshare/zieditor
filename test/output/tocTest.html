<p><div id="toc" class="toc"><ul class="toc-tree"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-number"></span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#准备工作"><span class="toc-number"></span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#知识准备"><span class="toc-number"></span> <span class="toc-text">知识准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求准备"><span class="toc-number"></span> <span class="toc-text">需求准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开始搭建"><span class="toc-number"></span> <span class="toc-text">开始搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工具推荐"><span class="toc-number"></span> <span class="toc-text">工具推荐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-number"></span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搭建骨架"><span class="toc-number"></span> <span class="toc-text">搭建骨架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按照需求安装依赖编写webpack.config.js"><span class="toc-number"></span> <span class="toc-text">按照需求安装依赖编写webpack.config.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加入环境变量"><span class="toc-number"></span> <span class="toc-text">加入环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现热加载"><span class="toc-number"></span> <span class="toc-text">实现热加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加es6语法支持"><span class="toc-number"></span> <span class="toc-text">添加es6语法支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加react"><span class="toc-number"></span> <span class="toc-text">添加react</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持各种文件加载"><span class="toc-number"></span> <span class="toc-text">支持各种文件加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理css样式兼容性，开发模式下将css单独出来"><span class="toc-number"></span> <span class="toc-text">处理css样式兼容性，开发模式下将css单独出来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用eslint和esformatter"><span class="toc-number"></span> <span class="toc-text">使用eslint和esformatter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他细节"><span class="toc-number"></span> <span class="toc-text">其他细节</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#聊聊其中的曲折和收获"><span class="toc-number"></span> <span class="toc-text">聊聊其中的曲折和收获</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最后"><span class="toc-number"></span> <span class="toc-text">最后</span></a></li></ul></div></p>
<h1><a name="背景" class="anchor" href="#背景"><span class="header-link"></span></a>背景</h1><p>公司的项目需要使用react，两三个月前还是一个基本不怎么懂前端，当时的我除了jquery什么都不知道，但是公司要求使用react开发新的项目，完全不懂前端的我只能去试着学习使用react进行开发，然后什么nodejs/webpack/es5/es6/babel/jsx一堆堆全部涌过来，讲真，彻底被前端的复杂世界搞懵逼了，从来没想过前端是这么的复杂。然后匆匆忙忙的开始学习，循环往复十来天。接着公司要求写项目了，我擦，我还什么都没学会，没办法，硬着头皮上，去全球最大同性交友网站（#雾）瞅了瞅，找了个star很多的脚手架，开始了开发之旅，其中的痛苦真的是不忍赘述，经常为了目标熬夜赶工，结果还是各种拖拖踏踏，一直没能完成。还好一个月后被叫去做其他项目，不然真的是崩崩崩。接下来的时间开始了真正的探索react路途...一两个月的工作之余熬夜苦学之后，尝试了很多不同的脚手架之后，开始有了自己对于开发、编译的需求，处于对于想要将一个技术完全征服的欲望，于是开始准备搭建自己的react脚手架</p>
<h1><a name="准备工作" class="anchor" href="#准备工作"><span class="header-link"></span></a>准备工作</h1><h2><a name="知识准备" class="anchor" href="#知识准备"><span class="header-link"></span></a>知识准备</h2><p>react自不必说，首先是去了解<a href="http://www.runoob.com/nodejs/nodejs-tutorial.html">nodejs</a>、<a href="https://webpack.js.org/">webpack</a>、<a href="http://babeljs.cn/">babel</a>、<a href="http://es6.ruanyifeng.com/">es6</a>等等，多学习源生js，彻底抛弃jquery才能真正感受到源生js带来的魅力，了解一些js规范，比如<a href="http://javascript.ruanyifeng.com/nodejs/module.html">commonjs</a>之类的。一定要用心去感悟（笑）。</p>
<h2><a name="需求准备" class="anchor" href="#需求准备"><span class="header-link"></span></a>需求准备</h2><p>对于个人的一路走来的感觉来说，前端开发经验少的人，应该还是先使用别人的脚手架，多读读人家的readme的说明，了解了解别人对于本项目的一些规范或者需求，这里推荐一个<a href="https://github.com/bodyno/react-starter-kit">react starter kit</a>，感觉确实很全面，不过里面没有使用jsx语法定义路由，而是使用的<a href="https://webpack.js.org/guides/code-splitting-require/">webpack的api来实现的按需加载</a>，开始可能会让人有点昏，不过多去了解了解也就没什么障碍，官方也给出了很好的解释。多写写，多动手，就会明白自己的一些需求了。这里列出我自己的一些想要的需求。</p>
<p>开发模式下：</p>
<ol>
<li>热加载（没它开发会累哭）</li>
<li>能与后台交互时的解决跨域问题</li>
</ol>
<p>生产模式下：</p>
<ol>
<li>能把react模块分开</li>
<li>能自动将生成js文件绑定到html页面</li>
<li>压缩js、css代码</li>
<li>想要使用ant design开发，但是antd样式文件较大，能够按需加载</li>
</ol>
<p>通用的：</p>
<ol>
<li>使用es6、jsx语法</li>
<li>能生成map文件</li>
<li>能加载各种文件：json，图片，字体，css，scss，less</li>
<li>找路径不要那么麻烦的使用 &#39;../../&#39;之类的，能直接从项目跟路径找。</li>
<li>命令能够兼容linux或者windows</li>
<li>使用eslint进行代码检查</li>
<li>使用esformatter进行代码格式化</li>
<li>能自动处理css样式兼容性问题</li>
</ol>
<h1><a name="开始搭建" class="anchor" href="#开始搭建"><span class="header-link"></span></a>开始搭建</h1><p>虽然我搭建环境有时候在linux有时候在windows，不过写此文的时候处于windows环境下，懒得切系统，所以统一使用windows环境，一般来说linux没什么不同，想起来有不同的时候我会说。</p>
<h2><a name="工具推荐" class="anchor" href="#工具推荐"><span class="header-link"></span></a>工具推荐</h2><p>强烈推荐vscode，支持得真的好=-=，虽然我还不是很用的来。</p>
<h2><a name="初始化" class="anchor" href="#初始化"><span class="header-link"></span></a>初始化</h2><p>安装nodejs，我使用nvm来管理不同的nodejs版本，而且通过nvm安装nodejs也超级简单，所以推荐用这种方式吧，<a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a>。下载安装，配置环境变量，搞定，具体教程自行百度。然后使用nvm安装最新的nodejs稳定版，目前是6.10.0。 <code>nvm install 6.10.0</code>，然后等安装完毕，新建一个react-start文件夹，cd进去， 使用命令 <code>nvm use 6.10.0</code> ，强烈建议安装cnpm 配置淘宝源，这样安装依赖会快得多，否则等秃（#雾，使用命令 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>,使用<code>cnpm init</code>初始化项目，基本上可以一路回车下去。完成初始化，安装全局webpack依赖<code>cnpm install webpack -g</code></p>
<h2><a name="搭建骨架" class="anchor" href="#搭建骨架"><span class="header-link"></span></a>搭建骨架</h2><p>跟路径新建webpack.config.js，webpack会默认读取这个文件，先编写个大概，然后慢慢去补</p>
<pre><code class="lang-js">&#39;use strict&#39;

const path = require( &#39;path&#39; )
const webpack = require( &#39;webpack&#39; )
const rootPath = path.resolve( __dirname )
const srcPath = path.join( rootPath, &#39;src&#39; )
const common = {
  rootPath: rootPath,
  srcPath: srcPath,
  dist: path.join( rootPath, &#39;dist&#39; ),
  indexHtml: path.join( srcPath, &#39;index.html&#39; ),
  staticDir: path.join( rootPath, &#39;static&#39; ),
  entry:path.join( common.srcPath, &#39;index.js&#39; )
}
var webpackConfig = {
    entry: common.entry,
    output: {
      filename: &#39;bundle.js&#39;,
      path: common.dist,
    },
}

module.exports = webpackConfig

</code></pre>
<p>新建src文件夹，我们编写的js源代码文件就写在这里面了
进入src文件夹，新建index.js</p>
<pre><code class="lang-js">    var render = function(){
        console.log(&#39;hello world&#39;);
    }
</code></pre>
<p>根目录新建dist文件夹，这是我们生成编译后的代码文件夹，新建index.html</p>
<pre><code class="lang-html">    &lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;react-starter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>根目录运行<code>webpack</code>，等待编译完成，浏览器打开index.html，打开控制台就能够看到hello world啦。</p>
<h2><a name="按照需求安装依赖编写webpack.config.js" class="anchor" href="#按照需求安装依赖编写webpack.config.js"><span class="header-link"></span></a>按照需求安装依赖编写webpack.config.js</h2><p>为了能够将项目迁移到其他电脑，本地安装webpack<code>cnpm install webpack --save-dev</code></p>
<h3><a name="加入环境变量" class="anchor" href="#加入环境变量"><span class="header-link"></span></a>加入环境变量</h3><p>为了实现linux和windows都能设置环境变量，安装cross-env，<code>cnpm install cross-env --save-dev</code>
修改config，加入</p>
<pre><code class="lang-js">const env = process
  .env
  .NODE_ENV
  .trim()
const isDev = (env === &#39;development&#39;)
</code></pre>
<h3><a name="实现热加载" class="anchor" href="#实现热加载"><span class="header-link"></span></a>实现热加载</h3><p>安装webpack-dev-server,<code>cnpm install webpack-dev-server</code>，编写config，</p>
<pre><code class="lang-js">&#39;use strict&#39;

const path = require( &#39;path&#39; )
const webpack = require( &#39;webpack&#39; )
const rootPath = path.resolve( __dirname )
const srcPath = path.join( rootPath, &#39;src&#39; )

const env = process
  .env
  .NODE_ENV
  .trim()
const isDev = (env === &#39;development&#39;)

const common = {
  rootPath: rootPath,
  srcPath: srcPath,
  dist: path.join( rootPath, &#39;dist&#39; ),
  indexHtml: path.join( srcPath, &#39;index.html&#39; ),
  staticDir: path.join( rootPath, &#39;static&#39; ),
  entry:path.join( common.srcPath, &#39;index.js&#39; )
}
//开发模式下修改入口文件
if ( isDev ) {
  common.entry = [
    &#39;react-hot-loader/patch&#39;,
    // activate HMR for React

    &#39;webpack-dev-server/client?http://localhost:3000&#39;,
    // bundle the client for webpack-dev-server and connect to the provided endpoint

    &#39;webpack/hot/only-dev-server&#39;,
    // bundle the client for hot reloading only- means to only hot reload for
    // successful updates

    path.join( common.srcPath, &#39;index.js&#39; )
  ]
}
var webpackConfig = {
    entry: common.entry,
    output: {
      filename: &#39;bundle.js&#39;,
      path: common.dist,
      publicPath: &#39;/&#39;, //让HMR知道在哪里加载热更新块所必需的
    },
}
//开发模式下添加devServer字段
//devServer候选字段参考https://webpack.js.org/configuration/dev-server/
if ( isDev ) {
  webpackConfig.devServer = {
    historyApiFallback:true,
    hot: true,
    contentBase: path.resolve( __dirname, &#39;dist&#39; ),
    publicPath: &#39;/&#39;,
    clientLogLevel: &#39;none&#39;, //日志
    compress: true, //压缩
    port:3000,
    stats: {
      colors: true
    },
    proxy:{
      &#39;/api/*&#39;:{
        target: &#39;http://localhost&#39;,
        changeOrigin: true,
        secure: false,
      }
    }
  }
}

module.exports = webpackConfig

</code></pre>
<h3><a name="添加es6语法支持" class="anchor" href="#添加es6语法支持"><span class="header-link"></span></a>添加es6语法支持</h3><p>webpack2.0好像默认支持es6语法，不过稳妥起见，还是使用Babel进行es2016转换</p>
<p>安装babel系列，<code>cnpm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-stage-0</code> 支持到js标准的stage 0阶段,
webpackConfig中添加module字段</p>
<pre><code class="lang-js">module: {
    //webpack1.0中可以省略 &#39;-loader&#39;，但是官方说法为了有明确的区分，在webpack2.0中，不能再省略
    rules: [
      {
        test: /\.(js)$/,
        loader: &#39;babel-loader&#39;,
        include: [
          path.join( common.rootPath, &#39;src&#39; ), //转换src路径下的代码
        ],
        exclude: /node_modules/, //忽略node_modules路径代码
      }
    ]
}

</code></pre>
<h3><a name="添加react" class="anchor" href="#添加react"><span class="header-link"></span></a>添加react</h3><p>安装react，<code>cnpm install --save react react-dom react-router</code> ，<code>cnpm install babel-preset-react react-hot-loader@^3.0.0-beta.6 babel-plugin-transform-runtime babel-preset-react babel-preset-react-optimize --save-dev</code>,继续修改webpackConfig,在上一个修改的代码中的test字段中，修改为：<code>test: /\.(js|jsx)$/,</code>
根目录新建.babelrc</p>
<pre><code class="lang-json">{
  &quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;, &quot;react&quot;],
  &quot;plugins&quot;: [&quot;transform-runtime&quot;,&quot;react-hot-loader/babel&quot;],
  &quot;env&quot;: {
    &quot;production&quot;: {
      &quot;presets&quot;: [&quot;react-optimize&quot;]
    }
  }
}
</code></pre>
<p>编写config</p>
<pre><code class="lang-js">&#39;use strict&#39;

const path = require( &#39;path&#39; )
const webpack = require( &#39;webpack&#39; )

const rootPath = path.resolve( __dirname )
const srcPath = path.join( rootPath, &#39;src&#39; )

const env = process
  .env
  .NODE_ENV
  .trim()
const isDev = (env === &#39;development&#39;)

const common = {
  rootPath: rootPath,
  srcPath: srcPath,
  dist: path.join( rootPath, &#39;dist&#39; ),
  indexHtml: path.join( srcPath, &#39;index.html&#39; ),
  staticDir: path.join( rootPath, &#39;static&#39; )
}
if ( isDev ) {
  common.entry = [
    &#39;react-hot-loader/patch&#39;,
    // activate HMR for React

    &#39;webpack-dev-server/client?http://localhost:3000&#39;,
    // bundle the client for webpack-dev-server and connect to the provided endpoint

    &#39;webpack/hot/only-dev-server&#39;,
    // bundle the client for hot reloading only- means to only hot reload for
    // successful updates

    path.join( common.srcPath, &#39;index.js&#39; )
  ]
}
if ( isDev ) {
    new webpack.HotModuleReplacementPlugin(), // HMR全局启用
    new webpack.NamedModulesPlugin(), // 在HMR更新的浏览器控制台中打印更易读的模块名称
  ]
} 
const webpackConfig = {
  entry: common.entry,
  output: {
    filename: &#39;bundle.js&#39;,
    path: common.dist,
    publicPath: &#39;/&#39;, //让HMR知道在哪里加载热更新块所必需的
  },
  context: path.resolve( __dirname, &#39;src&#39; ),
  module: {
    //webpack1.0中可以省略 &#39;-loader&#39;，但是官方说法为了有明确的区分，在webpack2.0中，不能再省略
    rules:[
        {
        test: /\.(js|jsx)$/,
        loader: &#39;babel-loader&#39;,
        include: [
          path.join( common.rootPath, &#39;src&#39; ), //转换src路径下的代码
        ],
        exclude: /node_modules/, //忽略node_modules路径代码
      }
    ]
  }
}
if ( isDev ) {
  webpackConfig.devServer = {
    historyApiFallback:true,
    hot: true,
    contentBase: path.resolve( __dirname, &#39;dist&#39; ),
    publicPath: &#39;/&#39;,
    clientLogLevel: &#39;none&#39;, //日志
    compress: true, //压缩
    port:3000,
    stats: {
      colors: true
    },
    proxy:{
      &#39;/api/*&#39;:{
        target: &#39;http://localhost&#39;,
        changeOrigin: true,
        secure: false,
      }
    }
  }
}

module.exports = webpackConfig
</code></pre>
<p>在html文件中加入
<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></p>
<p>新建/src/components文件夹
新建/src/components/index.js</p>
<pre><code class="lang-jsx">    import React,{Component} from &#39;react&#39;
    export const App = ()=&gt;(
        &lt;div&gt;hello world!&lt;div&gt;
    )
</code></pre>
<p>编写/src/index.js</p>
<pre><code class="lang-js">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;

import { AppContainer } from &#39;react-hot-loader&#39;
// AppContainer is a necessary wrapper component for HMR

const Root = document.getElementById( &#39;root&#39; )

const isDev = !(process.env.NODE_ENV === &#39;development&#39;)

let render = () =&gt; {
  const Routes = require( &#39;./routes/index&#39; ).default
  ReactDOM.render( &lt;AppContainer&gt;&lt;Routes/&gt;&lt;/AppContainer&gt;, Root )
}

if ( isDev ) {
  if ( window.devToolsExtension ) {
    window.devToolsExtension.open()
  }
}

if ( isDev ) {
  if ( module.hot ) {
    // Development render functions
    const renderApp = render

    // Wrap render in try/catch
    render = () =&gt; {
        renderApp()
    }

    // Setup hot module replacement
    module.hot.accept( &#39;./components&#39;, () =&gt; setImmediate( () =&gt; {
      ReactDOM.unmountComponentAtNode( Root )
      render()
    } )
    )
  }
}

// Hot Module Replacement API
// if (module.hot) {
//   module
//     .hot
//     .accept(&#39;./&#39;, () =&gt; {
//       render(Routers)
//     })
// }

render()
</code></pre>
<p>运行命令 <code>cross-env NODE_ENV=development  webpack-dev-server</code> 打开浏览器，输入localhost:3000看看是不是已经有了hell world啦？在源文件中将hello world修改成其他字样，看看是不是已经能够自动刷新网页了？可喜可贺~</p>
<h4><a name="支持各种文件加载" class="anchor" href="#支持各种文件加载"><span class="header-link"></span></a>支持各种文件加载</h4><p>在webpack概念中，各种文件都可以通过loader达到all in js的效果，从而让js能够做各种操作
所以接下来要安装各种loader，
<code>cnpm install --save css-loader file-loader html-loader json-loader less less-loader node-sass sass-loader style-loader url-loader</code></p>
<p>简单说明（一下省略 “-loader”）：</p>
<ul>
<li>style:将css样式转换成 css in js，也就是说没有单独的css文件，全部都在js文件中夹杂着，这里引入主要是为了热加载</li>
<li>css、file、html、json、less、sass：顾名思义就是将这些类型文件加载到js中</li>
<li>less、node-sass：因为less和sass是预处理语言，要使其发挥作用，必须加入这些支持</li>
<li>url-loader:file-loader的加强版，可以使用limit参数，主要用来加载图片</li>
</ul>
<p>修改config</p>
<pre><code class="lang-js">/**
 * webpack2.0 配置文件
 * @authors wuhongxu (wuhongxu1208@gmail.com)
 * @date    2017-03-10 01:52:00
 * @version 1.0.0
 * @link &lt;link&gt;https://zido.site/&lt;/link&gt;
 *
 */

&#39;use strict&#39;

const path = require( &#39;path&#39; )
const webpack = require( &#39;webpack&#39; )

const rootPath = path.resolve( __dirname )
const srcPath = path.join( rootPath, &#39;src&#39; )

const env = process
  .env
  .NODE_ENV
  .trim()
const isDev = (env === &#39;development&#39;)

const common = {
  rootPath: rootPath,
  srcPath: srcPath,
  dist: path.join( rootPath, &#39;dist&#39; ),
  indexHtml: path.join( srcPath, &#39;index.html&#39; ),
  staticDir: path.join( rootPath, &#39;static&#39; )
}
if ( isDev ) {
  common.entry = [
    &#39;react-hot-loader/patch&#39;,
    // activate HMR for React

    &#39;webpack-dev-server/client?http://localhost:3000&#39;,
    // bundle the client for webpack-dev-server and connect to the provided endpoint

    &#39;webpack/hot/only-dev-server&#39;,
    // bundle the client for hot reloading only- means to only hot reload for
    // successful updates

    path.join( common.srcPath, &#39;index.js&#39; )
  ]
} else {
  common.entry = {
    app: path.join( common.srcPath, &#39;index.js&#39; )
}

const styleLoaders = {
  style: {
    loader: &#39;style-loader&#39;
  },
  css: {
    loader: &#39;css-loader&#39;,
    options: {
      //将css进行hash编码，保证模块性，保证单独使用，而不会污染全局
      // modules: true
    }
  }
}

const webpackConfig = {
  entry: common.entry,
  output: {
    filename: &#39;bundle.js&#39;,
    path: common.dist,
    publicPath: &#39;/&#39;, //让HMR知道在哪里加载热更新块所必需的
  },
  context: path.resolve( __dirname, &#39;src&#39; ),
  module: {
    //webpack1.0中可以省略 &#39;-loader&#39;，但是官方说法为了有明确的区分，在webpack2.0中，不能再省略
    rules: [
      {
        test: /\.(js|jsx)$/,
        loader: &#39;babel-loader&#39;,
        include: [
          path.join( common.rootPath, &#39;src&#39; ), //转换src路径下的代码
        ],
        exclude: /node_modules/, //忽略node_modules路径代码
      },
      {
        test: /\.json$/,
        use: &#39;json-loader&#39;
      },
      {
        test: /.html$/,
        use: &#39;html-loader&#39;
      },
      {
        test: /\.(woff2?|eot|ttf|otf)$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            limit: 10240,
            name: &#39;[name]-[hash:6].[ext]&#39;
          }
        }
      },
      {
        test: /\.(png|jpg|gif|svg)$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            limit: 10240,
            name: &#39;[name]-[hash:6].[ext]&#39;
          }
        }
      },
      {
        test: /\.css$/,
        use: ( handleStyle( extractCss, [
          styleLoaders.style,
          styleLoaders.css,
          styleLoaders.postcss
        ] ))
      },
      {
        test: /\.scss$/,
        use: ( handleStyle( extractScss, [
          styleLoaders.style,
          styleLoaders.css,
          styleLoaders.postcss,
          {
            loader: &#39;sass-loader&#39;
          }
        ] ))
      },
      {
        test: /\.less$/,
        use: ( handleStyle( extractLess, [
          styleLoaders.style,
          styleLoaders.css,
          styleLoaders.postcss,
          {
            loader: &#39;less-loader&#39;
          }
        ] ))
      }
    ]
  }
}
if ( isDev ) {
  webpackConfig.devServer = {
    historyApiFallback:true,
    hot: true,
    contentBase: path.resolve( __dirname, &#39;dist&#39; ),
    publicPath: &#39;/&#39;,
    clientLogLevel: &#39;none&#39;, //日志
    compress: true, //压缩
    port:3000,
    stats: {
      colors: true
    },
    proxy:{
      &#39;/api/*&#39;:{
        target: &#39;http://localhost&#39;,
        changeOrigin: true,
        secure: false,
      }
    }
  }
}

module.exports = webpackConfig


</code></pre>
<h3><a name="处理css样式兼容性，开发模式下将css单独出来" class="anchor" href="#处理css样式兼容性，开发模式下将css单独出来"><span class="header-link"></span></a>处理css样式兼容性，开发模式下将css单独出来</h3><p>此时需要引入css后处理器postcss，然后使用<a href="https://github.com/postcss/autoprefixer">autoprefixer</a>来进行前缀配置，css文件单独出来需要使用webpack的插件extractPlugin ，安装依赖，<code>cnpm install autoprefixer-loader extract-text-webpack-plugin postcss-loader --save-dev</code>
编写postcss.config.js</p>
<pre><code class="lang-js">//处理css前缀，用来更好的兼容各种浏览器
//在 package.json中 使用 browserslist 字段已经定义好了浏览器适配（官方推荐）
module.exports = {
  plugins: [
    require(&#39;autoprefixer&#39;)
  ]
}
</code></pre>
<p>在package.json中添加字段</p>
<pre><code class="lang-json">  &quot;browserslist&quot;: [
    &quot;&gt; 1%&quot;,
    &quot;last 2 versions&quot;
  ],
</code></pre>
<p>编写webpack.config.js</p>
<pre><code class="lang-js">&#39;use strict&#39;

const path = require( &#39;path&#39; )
const webpack = require( &#39;webpack&#39; )

//使用插件
const HtmlWebpackPlugin = require( &#39;html-webpack-plugin&#39; )
const ExtractTextPlugin = require( &#39;extract-text-webpack-plugin&#39; )
const extractCss = new ExtractTextPlugin( &#39;style/[name]-css-[hash:6].css&#39; )
const extractScss = new ExtractTextPlugin( &#39;style/[name]-scss-[hash:6].css&#39; )
const extractLess = new ExtractTextPlugin( &#39;style/[name]-less-[hash:6].css&#39; )

const rootPath = path.resolve( __dirname )
const srcPath = path.join( rootPath, &#39;src&#39; )

const env = process
  .env
  .NODE_ENV
  .trim()
const isDev = (env === &#39;development&#39;)

const common = {
  rootPath: rootPath,
  srcPath: srcPath,
  dist: path.join( rootPath, &#39;dist&#39; ),
  indexHtml: path.join( srcPath, &#39;index.html&#39; ),
  staticDir: path.join( rootPath, &#39;static&#39; )
}
if ( isDev ) {
  common.entry = [
    &#39;react-hot-loader/patch&#39;,
    // activate HMR for React

    &#39;webpack-dev-server/client?http://localhost:3000&#39;,
    // bundle the client for webpack-dev-server and connect to the provided endpoint

    &#39;webpack/hot/only-dev-server&#39;,
    // bundle the client for hot reloading only- means to only hot reload for
    // successful updates

    path.join( common.srcPath, &#39;index.js&#39; )
  ]
} else {
  common.entry = {
    app: path.join( common.srcPath, &#39;index.js&#39; ),
    vendor: [
      &#39;react&#39;
    ]
  }
}
if ( isDev ) {
  common.plugins = [
    new HtmlWebpackPlugin( {
      template: common.indexHtml,
      inject: &#39;body&#39;
    } ),
    new webpack.HotModuleReplacementPlugin(), // HMR全局启用
    new webpack.NamedModulesPlugin(), // 在HMR更新的浏览器控制台中打印更易读的模块名称
  ]
} else {
  common.plugins = [
    new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin( {
      template: common.indexHtml,
      inject: &#39;body&#39;
    } ),
    new webpack.NoEmitOnErrorsPlugin(),
    // stataic目录下静态资源的复制
    new CopyWebpackPlugin( [
      {
        context: common.rootPath,
        from: &#39;static/*&#39;,
        ignore: [
          &#39;*.md&#39;
        ]
      }
    ] ),
    new webpack.optimize.CommonsChunkPlugin( {
      name: &#39;vendor&#39;,
      filename: &#39;vendor.bundle.js&#39;
    } )
  ]
}

common.plugins.push( new webpack.DefinePlugin( {
  &#39;process.env&#39;: {
    NODE_ENV: JSON.stringify(env)
  }
} ) )
const styleLoaders = {
  style: {
    loader: &#39;style-loader&#39;
  },
  css: {
    loader: &#39;css-loader&#39;,
    options: {
      //将css进行hash编码，保证模块性，保证单独使用，而不会污染全局
      // modules: true
    }
  },
  postcss: {
    //css后处理器，这里主要是为了加载 autoprefixer 用来处理css前缀
    loader: &#39;postcss-loader&#39;
  }
}
function handleStyle( plugin, list ) {
  //如果不是开发模式，删除数组中的第一个元素，并使用extrat-plugin将样式额外打包
  if ( !isDev ) {
    list.splice( 0, 1 )
    return plugin.extract( list )
  }
  return list
}

const webpackConfig = {
  entry: common.entry,
  output: {
    filename: &#39;bundle.js&#39;,
    path: common.dist,
    publicPath: &#39;/&#39;, //让HMR知道在哪里加载热更新块所必需的
  },
  context: path.resolve( __dirname, &#39;src&#39; ),
  devtool: isDev
    ? &#39;cheap-module-eval-source-map&#39;
    : &#39;cheap-module-source-map&#39;,
  module: {
    //webpack1.0中可以省略 &#39;-loader&#39;，但是官方说法为了有明确的区分，在webpack2.0中，不能再省略
    rules: [
      {
        test: /\.(js|jsx)$/,
        enforce: &#39;pre&#39;,
        loader: &#39;eslint-loader&#39;,
        exclude: /node_modules/,
        options: {
          emitWarning: true,
          emitError: true,
          //failOnWarning: false, failOnError: true,
          useEslintrc: false,
          // configFile: path.join(__dirname, &quot;eslint_conf.js&quot;)
          configFile: path.join( __dirname, &#39;.eslintrc.json&#39; )
        }
      },
      {
        test: /\.(js|jsx)$/,
        loader: &#39;babel-loader&#39;,
        include: [
          path.join( common.rootPath, &#39;src&#39; ), //转换src路径下的代码
        ],
        exclude: /node_modules/, //忽略node_modules路径代码
        options:{
          plugins: [
            [&#39;import&#39;, [{ libraryName: &#39;antd&#39;, style: &#39;css&#39; }]],//按需加载antd 样式，有效小包大小
          ]
        }
      },
      {
        test: /\.json$/,
        use: &#39;json-loader&#39;
      },
      {
        test: /.html$/,
        use: &#39;html-loader&#39;
      },
      {
        test: /\.(woff2?|eot|ttf|otf)$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            limit: 10240,
            name: &#39;[name]-[hash:6].[ext]&#39;
          }
        }
      },
      {
        test: /\.(png|jpg|gif|svg)$/,
        use: {
          loader: &#39;url-loader&#39;,
          options: {
            limit: 10240,
            name: &#39;[name]-[hash:6].[ext]&#39;
          }
        }
      },
      {
        test: /\.css$/,
        use: ( handleStyle( extractCss, [
          styleLoaders.style,
          styleLoaders.css,
          styleLoaders.postcss
        ] ))
      },
      {
        test: /\.scss$/,
        use: ( handleStyle( extractScss, [
          styleLoaders.style,
          styleLoaders.css,
          styleLoaders.postcss,
          {
            loader: &#39;sass-loader&#39;
          }
        ] ))
      },
      {
        test: /\.less$/,
        use: ( handleStyle( extractLess, [
          styleLoaders.style,
          styleLoaders.css,
          styleLoaders.postcss,
          {
            loader: &#39;less-loader&#39;
          }
        ] ))
      }
    ]
  },
  resolve: {
    extensions: [
      &#39;.js&#39;,
      &#39;.jsx&#39;,
      &#39;.json&#39;
    ],
    alias: {
      Root: path.resolve( __dirname, &#39;src&#39; ),
      Components: path.resolve( __dirname, &#39;src/components&#39; ),
      Layouts: path.resolve( __dirname, &#39;src/layouts&#39; ),
      Routes: path.resolve( __dirname, &#39;src/routes&#39; ),
    } //为某些路径设置别名
  },
  plugins: (function () {
    //如果是开发模式不将样式文件进行分离。tip:为了实现热加载
    if ( isDev )
      return common.plugins
    common
      .plugins
      .push( extractCss )
    common
      .plugins
      .push( extractLess )
    common
      .plugins
      .push( extractScss )
    //返回组装完成后的plugins
    return common.plugins
  })()
}
if ( isDev ) {
  webpackConfig.devServer = {
    historyApiFallback:true,
    hot: true,
    contentBase: path.resolve( __dirname, &#39;dist&#39; ),
    publicPath: &#39;/&#39;,
    clientLogLevel: &#39;none&#39;, //日志
    compress: true, //压缩
    port:3000,
    stats: {
      colors: true
    },
    proxy:{
      &#39;/api/*&#39;:{
        target: &#39;http://localhost&#39;,
        changeOrigin: true,
        secure: false,
      }
    }
  }
}

module.exports = webpackConfig
</code></pre>
<h3><a name="使用eslint和esformatter" class="anchor" href="#使用eslint和esformatter"><span class="header-link"></span></a>使用eslint和esformatter</h3><p>这一步的作用其实不是很大，更多的是自定义一个js代码的规范，其实不标准照样可以运行
安装eslint和esformatter的各项依赖，<code>cnpm install --save-dev eslint esformatter es-strip-semicolons eslint-config-airbnb eslint-loader eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react</code></p>
<p>根目录新建.esformatter,这里的代码太长且不重要，这里不贴了，<a href="https://github.com/Userwu/react-starter/blob/master/.esformatter">github地址</a>,请自行查看</p>
<p>根目录新建 .eslintrc.json 同上，<a href="https://github.com/Userwu/react-starter/blob/master/.eslintrc.json">github地址</a></p>
<p>编写webpack.config.js</p>
<p>在module.rules里面新增</p>
<pre><code class="lang-js">{
        test: /\.(js|jsx)$/,
        enforce: &#39;pre&#39;,
        loader: &#39;eslint-loader&#39;,
        exclude: /node_modules/,
        options: {
          emitWarning: true,
          emitError: true,
          //failOnWarning: false, failOnError: true,
          useEslintrc: false,
          // configFile: path.join(__dirname, &quot;eslint_conf.js&quot;)
          configFile: path.join( __dirname, &#39;.eslintrc.json&#39; )
        }
      },
</code></pre>
<p>这样会强制在运行前检查js代码，非常严格，一旦有错将不能运行，如果觉得没必要，可以去掉这一段代码</p>
<h3><a name="其他细节" class="anchor" href="#其他细节"><span class="header-link"></span></a>其他细节</h3><p>其他小的细节，是一看就懂的，这里就不再赘述步骤。</p>
<p>项目的<a href="https://github.com/Userwu/react-starter">github地址</a></p>
<h1><a name="聊聊其中的曲折和收获" class="anchor" href="#聊聊其中的曲折和收获"><span class="header-link"></span></a>聊聊其中的曲折和收获</h1><p>其实本来这个项目开始是使用webpack1.x搭建的，结果搭建好之后，才知道，喵蛋的，2.x都出来了，于是果断放弃之前的，将项目速度改进到2.x版本。</p>
<p>很多东西都是根据其他的项目而来，但是那些版本都太老旧了，很多的依赖都是我看了名字之后，转而去github或者npm查看新版本的用法，这段是最费时间，最费眼睛的了（因为我的英文实在是差劲QAQ，要不是chrome的翻译插件，我估计我已经崩了），对于我这种特别崇尚最新的人来说，用老旧的东西，是我非常非常不能忍受的，所以我用的依赖基本上都是最新的，其中有些除了github上面，其他地方基本都么有相关资料。</p>
<p>说实话，做出来之后，还能很好的运行，我真的是长长的出了一口大气，很舒心的感觉，终于特么的我走通一回了，好气啊~~~</p>
<p>最大的收获，就是这一份走通的感觉了吧，个人前端后端都在弄，一直依赖都是两边奔波却基本上都没怎么摸透过。感觉暂时前端终于能稍微放一下，继续搞后端，目标分布式和并发，走起！</p>
<p>写完这篇都特么快五点了，必须得睡觉了。顺便也请各位纠纠错，其实写的时候也没多仔细，难免会有所遗漏与错误。</p>
<h1><a name="最后" class="anchor" href="#最后"><span class="header-link"></span></a>最后</h1><p>最新最新的react脚手架<a href="https://github.com/Userwu/react-starter">react-starter</a>，算是提供个思路和参考吧，有用请star~ 也请大佬们能够帮我修改修改 :smile:</p>
